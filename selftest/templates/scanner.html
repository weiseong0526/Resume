<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-Time Barcode Scanner</title>
    <script src="https://cdn.jsdelivr.net/npm/@zxing/library@0.20.0/umd/index.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 1200px;
            width: 100%;
            padding: 30px;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 0.9em;
        }

        .scanner-section {
            display: block;
            margin-bottom: 30px;
        }

        .video-container {
            position: relative;
            background: #000;
            border-radius: 15px;
            overflow: hidden;
            aspect-ratio: 4/3;
        }

        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .scanner-overlay {
            display: none; /* Hidden - only show tracking box when barcode detected */
        }

        #trackingCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            background: transparent;
        }


        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #5a6268;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .status {
            text-align: center;
            padding: 10px;
            margin: 15px 0;
            border-radius: 10px;
            font-weight: 500;
        }

        .status.active {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.inactive {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-indicator.active {
            background: #28a745;
            box-shadow: 0 0 10px rgba(40, 167, 69, 0.5);
        }

        .status-indicator.inactive {
            background: #dc3545;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ“· Real-Time Barcode Scanner</h1>
        <p class="subtitle">Point your camera at a barcode or QR code to scan</p>

        <div class="scanner-section">
            <div class="video-container">
                <video id="video" autoplay playsinline muted></video>
                <div class="scanner-overlay" id="scannerOverlay"></div>
                <canvas id="trackingCanvas"></canvas>
            </div>
            
            <div id="status" class="status inactive" style="margin-top: 20px;">
                <span class="status-indicator inactive"></span>
                <span id="statusText">Camera Stopped</span>
            </div>
        </div>

        <div class="controls">
            <button class="btn btn-primary" id="startBtn" onclick="startScanning()">Start Camera</button>
            <button class="btn btn-secondary" id="stopBtn" onclick="stopScanning()" disabled>Stop Camera</button>
        </div>
    </div>

    <script>
        let video = null;
        let codeReader = null;
        let scanning = false;
        let stream = null;
        let scanCanvas = null;
        let animationFrameId = null;
        let trackingCanvas = null;
        let trackingCtx = null;
        let lastScannedCode = null;
        let clearCheckInterval = null; // For direct video decoding timeout

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            video = document.getElementById('video');
            trackingCanvas = document.getElementById('trackingCanvas');
            if (trackingCanvas) {
                trackingCtx = trackingCanvas.getContext('2d');
            }
            
            // Initialize ZXing
            initializeZXing();
        });

        function initializeZXing() {
            // Wait for ZXing library to load
            let retryCount = 0;
            const maxRetries = 50;
            
            function checkZXing() {
                if (typeof ZXing !== 'undefined' && ZXing.BrowserMultiFormatReader) {
                    try {
                        codeReader = new ZXing.BrowserMultiFormatReader();
                        
                        // Explicitly enable ALL barcode formats (not just QR codes)
                        try {
                            if (codeReader.setHints && ZXing.DecodeHintType && ZXing.BarcodeFormat) {
                                const hints = new Map();
                                // Enable ALL formats - both barcodes and QR codes
                                const allFormats = [
                                    ZXing.BarcodeFormat.QR_CODE,        // QR Codes
                                    ZXing.BarcodeFormat.CODE_128,       // Barcodes
                                    ZXing.BarcodeFormat.CODE_39,        // Barcodes
                                    ZXing.BarcodeFormat.CODE_93,        // Barcodes
                                    ZXing.BarcodeFormat.EAN_13,         // Barcodes
                                    ZXing.BarcodeFormat.EAN_8,          // Barcodes
                                    ZXing.BarcodeFormat.UPC_A,          // Barcodes
                                    ZXing.BarcodeFormat.UPC_E,          // Barcodes
                                    ZXing.BarcodeFormat.CODABAR,        // Barcodes
                                    ZXing.BarcodeFormat.ITF,            // Barcodes
                                    ZXing.BarcodeFormat.RSS_14,         // Barcodes
                                    ZXing.BarcodeFormat.RSS_EXPANDED,  // Barcodes
                                    ZXing.BarcodeFormat.DATA_MATRIX,    // 2D codes
                                    ZXing.BarcodeFormat.PDF_417,        // 2D codes
                                    ZXing.BarcodeFormat.AZTEC          // 2D codes
                                ];
                                hints.set(ZXing.DecodeHintType.POSSIBLE_FORMATS, allFormats);
                                codeReader.setHints(hints);
                                console.log('âœ“ All barcode formats enabled: QR Codes + Barcodes');
                            }
                        } catch (hintError) {
                            // BrowserMultiFormatReader supports all by default, but try to set hints anyway
                            console.log('Note: Using default format support (includes all barcodes and QR codes)');
                        }
                        
                        console.log('âœ“ ZXing initialized - Barcode & QR Code scanner ready');
                        console.log('  âœ“ QR Codes - Supported');
                        console.log('  âœ“ Barcodes (CODE_128, EAN, UPC, etc.) - Supported');
                        updateStatus(false, 'Ready - Click "Start Camera" to begin');
                        return true;
                    } catch (e) {
                        console.error('Error initializing ZXing:', e);
                    }
                }
                
                retryCount++;
                if (retryCount < maxRetries) {
                    setTimeout(checkZXing, 100);
                } else {
                    console.error('ZXing library failed to load');
                    updateStatus(false, 'Library loading failed - Please refresh');
                }
                return false;
            }
            
            checkZXing();
        }

        async function startScanning() {
            try {
                if (!codeReader) {
                    alert('Scanner not ready. Please wait for library to load or refresh the page.');
                    return;
                }

                updateStatus(true, 'Starting camera...');

                // Get user media
                stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });

                video.srcObject = stream;
                video.setAttribute('autoplay', '');
                video.setAttribute('playsinline', '');
                video.setAttribute('muted', '');

                // Wait for video to be ready
                await new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        resolve();
                    };
                });

                await video.play();

                // Set canvas size to match video
                if (trackingCanvas && video && video.videoWidth > 0) {
                    trackingCanvas.width = video.videoWidth;
                    trackingCanvas.height = video.videoHeight;
                    console.log('âœ“ Tracking canvas sized:', trackingCanvas.width, 'x', trackingCanvas.height);
                    clearTrackingBox();
                } else {
                    // Retry sizing after video metadata loads
                    video.addEventListener('loadedmetadata', () => {
                        if (trackingCanvas && video && video.videoWidth > 0) {
                            trackingCanvas.width = video.videoWidth;
                            trackingCanvas.height = video.videoHeight;
                            console.log('âœ“ Tracking canvas sized (after metadata):', trackingCanvas.width, 'x', trackingCanvas.height);
                            clearTrackingBox();
                        }
                    }, { once: true });
                }

                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                
                scanning = true;
                updateStatus(true, 'Scanning...');
                
                // Start scanning
                setTimeout(() => {
                    startBarcodeDetection();
                }, 500);
                
            } catch (err) {
                console.error('Error accessing camera:', err);
                updateStatus(false, 'Camera Error: ' + err.message);
                alert('Error accessing camera: ' + err.message);
            }
        }

        function startBarcodeDetection() {
            if (!scanning || !codeReader) return;

            // Try to use direct video decoding first (much faster)
            if (codeReader.decodeFromVideoDevice) {
                console.log('Using fast decodeFromVideoDevice method');
                useDirectVideoDecoding();
                return;
            }

            // Fallback to frame-by-frame (slower but works everywhere)
            console.log('Using frame-by-frame method');
            startFrameByFrameScanning();
        }

        function useDirectVideoDecoding() {
            // Direct video stream decoding - fastest method
            let lastBarcodeTime = 0;
            const BARCODE_TIMEOUT_MS = 1000; // Clear if no barcode for 1 second (longer timeout to keep box visible)
            
            // Clear box periodically if no barcode detected (but with longer timeout)
            clearCheckInterval = setInterval(() => {
                if (!scanning) {
                    if (clearCheckInterval) {
                        clearInterval(clearCheckInterval);
                        clearCheckInterval = null;
                    }
                    clearTrackingBox();
                    return;
                }
                const now = Date.now();
                // Only clear if no barcode detected for 1 second - keeps box visible while barcode is readable
                if (now - lastBarcodeTime > BARCODE_TIMEOUT_MS && lastBarcodeTime > 0) {
                    clearTrackingBox();
                    lastBarcodeTime = 0;
                }
            }, 200); // Check every 200ms instead of 100ms
            
            try {
                codeReader.decodeFromVideoDevice(null, video, (result, error) => {
                    if (error) {
                        // NotFoundException is normal - no barcode found yet
                        // Don't clear immediately - let timeout interval handle it to prevent flickering
                        return;
                    }
                    
                    if (result && scanning) {
                        let scannedText;
                        try {
                            if (typeof result.getText === 'function') {
                                scannedText = result.getText();
                            } else if (result.text) {
                                scannedText = result.text;
                            } else {
                                scannedText = String(result);
                            }

                            if (scannedText && scannedText.trim().length > 0) {
                                // Update last barcode detection time
                                lastBarcodeTime = Date.now();
                                
                                // Always update tracking (even if same code) so box follows movement
                                lastScannedCode = scannedText;
                                
                                // Get barcode position for tracking - try multiple methods
                                let barcodePosition = null;
                                
                                // Method 1: getResultPoints()
                                if (result.getResultPoints && typeof result.getResultPoints === 'function') {
                                    try {
                                        barcodePosition = result.getResultPoints();
                                    } catch (e) {
                                        console.log('getResultPoints() error:', e);
                                    }
                                }
                                
                                // Method 2: resultPoints property
                                if (!barcodePosition && result.resultPoints) {
                                    barcodePosition = result.resultPoints;
                                }
                                
                                // Method 3: Try to get from result metadata
                                if (!barcodePosition && result.resultMetadata) {
                                    try {
                                        const metadata = result.resultMetadata;
                                        if (metadata.getResultPoints) {
                                            barcodePosition = metadata.getResultPoints();
                                        }
                                    } catch (e) {}
                                }

                                // Get barcode format
                                let format = 'UNKNOWN';
                                try {
                                    if (result.getBarcodeFormat) {
                                        format = result.getBarcodeFormat().toString();
                                    } else if (result.barcodeFormat) {
                                        format = result.barcodeFormat.toString();
                                    }
                                } catch (e) {}

                                // Draw tracking box with barcode text displayed inside
                                // Update continuously so box follows the barcode as it moves
                                if (barcodePosition && barcodePosition.length > 0 && trackingCtx) {
                                    drawTrackingBox(barcodePosition, scannedText, format);
                                } else {
                                    // If no points, create a box in center area
                                    drawCenterTrackingBox(scannedText, format);
                                }

                                // Results panel removed - barcode shown only in tracking box
                            } else {
                                // No valid barcode text - don't clear immediately
                                // Let timeout mechanism handle it to keep box visible while barcode is readable
                            }
                        } catch (e) {
                            console.error('Error processing result:', e);
                            // Only clear on actual errors, not on "not found" cases
                            // Let timeout mechanism handle normal "not found" cases
                        }
                    } else {
                        // No result - don't clear immediately
                        // Let timeout mechanism handle it to keep box visible while barcode is readable
                    }
                });
            } catch (e) {
                console.error('Direct video decoding failed, using fallback:', e);
                startFrameByFrameScanning();
            }
        }

        function startFrameByFrameScanning() {
            // Create canvas for capturing frames
            if (!scanCanvas) {
                scanCanvas = document.createElement('canvas');
            }

            let frameCount = 0;
            const SCAN_INTERVAL = 100; // Scan every 100ms (faster - was 200ms)
            let lastScanTime = 0;

            // Track when we last detected a barcode
            let lastBarcodeDetectedTime = 0;
            const BARCODE_TIMEOUT = 1000; // Clear box if no barcode detected for 1 second (longer timeout)

            function scanFrame() {
                if (!scanning) {
                    clearTrackingBox();
                    return;
                }

                const now = Date.now();
                
                // Clear box only if no barcode detected for a longer time (1 second)
                // This keeps the box visible as long as barcode is being read
                if (now - lastBarcodeDetectedTime > BARCODE_TIMEOUT && lastBarcodeDetectedTime > 0) {
                    clearTrackingBox();
                    lastBarcodeDetectedTime = 0;
                }
                
                if (now - lastScanTime < SCAN_INTERVAL) {
                    animationFrameId = requestAnimationFrame(scanFrame);
                    return;
                }
                lastScanTime = now;

                // Check if video is ready
                if (!video || video.readyState !== video.HAVE_ENOUGH_DATA || video.videoWidth === 0) {
                    // Don't clear immediately - wait for timeout
                    animationFrameId = requestAnimationFrame(scanFrame);
                    return;
                }

                try {
                    // Use smaller canvas for faster processing (barcodes don't need full resolution)
                    // Max 800px width for faster encoding/decoding
                    const maxWidth = 800;
                    let canvasWidth = video.videoWidth;
                    let canvasHeight = video.videoHeight;
                    
                    if (canvasWidth > maxWidth) {
                        canvasHeight = (canvasHeight * maxWidth) / canvasWidth;
                        canvasWidth = maxWidth;
                    }
                    
                    // Update canvas size (only if changed)
                    if (scanCanvas.width !== canvasWidth || scanCanvas.height !== canvasHeight) {
                        scanCanvas.width = canvasWidth;
                        scanCanvas.height = canvasHeight;
                    }

                    // Draw video frame to canvas (scaled down for speed)
                    const ctx = scanCanvas.getContext('2d');
                    ctx.drawImage(video, 0, 0, canvasWidth, canvasHeight);

                    // Convert to image - use JPEG for faster encoding (smaller file size)
                    const img = new Image();
                    img.onload = () => {
                        if (!codeReader || !codeReader.decodeFromImageElement) {
                            animationFrameId = requestAnimationFrame(scanFrame);
                            return;
                        }

                        // Try to decode barcode with timeout
                        const decodePromise = codeReader.decodeFromImageElement(img);
                        const timeoutPromise = new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Timeout')), 500)
                        );
                        
                        Promise.race([decodePromise, timeoutPromise])
                            .then(result => {
                                if (result && scanning) {
                                    let scannedText;
                                    try {
                                        if (typeof result.getText === 'function') {
                                            scannedText = result.getText();
                                        } else if (result.text) {
                                            scannedText = result.text;
                                        } else {
                                            scannedText = String(result);
                                        }

                                        if (scannedText && scannedText.trim().length > 0) {
                                            // Update last detection time
                                            lastBarcodeDetectedTime = Date.now();
                                            
                                            // Always update tracking (even if same code) so box follows movement
                                            lastScannedCode = scannedText;
                                            
                                            // Get barcode position for tracking - try multiple methods
                                            let barcodePosition = null;
                                            
                                            // Method 1: getResultPoints()
                                            if (result.getResultPoints && typeof result.getResultPoints === 'function') {
                                                try {
                                                    barcodePosition = result.getResultPoints();
                                                } catch (e) {
                                                    console.log('getResultPoints() error:', e);
                                                }
                                            }
                                            
                                            // Method 2: resultPoints property
                                            if (!barcodePosition && result.resultPoints) {
                                                barcodePosition = result.resultPoints;
                                            }
                                            
                                            // Method 3: Try to get from result metadata
                                            if (!barcodePosition && result.resultMetadata) {
                                                try {
                                                    const metadata = result.resultMetadata;
                                                    if (metadata.getResultPoints) {
                                                        barcodePosition = metadata.getResultPoints();
                                                    }
                                                } catch (e) {}
                                            }

                                            // Get barcode format
                                            let format = 'UNKNOWN';
                                            try {
                                                if (result.getBarcodeFormat) {
                                                    format = result.getBarcodeFormat().toString();
                                                } else if (result.barcodeFormat) {
                                                    format = result.barcodeFormat.toString();
                                                }
                                            } catch (e) {}

                                            // Draw tracking box with barcode text displayed inside
                                            // Update continuously so box follows the barcode
                                            if (barcodePosition && barcodePosition.length > 0 && trackingCtx) {
                                                drawTrackingBox(barcodePosition, scannedText, format);
                                            } else {
                                                // If no points, create a box in center area
                                                drawCenterTrackingBox(scannedText, format);
                                            }

                                            // Results panel removed - barcode shown only in tracking box
                                        } else {
                                            // No valid barcode text - don't clear immediately
                                            // Let timeout mechanism handle it to keep box visible while barcode is readable
                                        }
                                    } catch (e) {
                                        console.error('Error processing result:', e);
                                        // Only clear on actual errors, not on "not found" cases
                                        // Let timeout mechanism handle normal "not found" cases
                                    }
                                } else {
                                    // No result - don't clear immediately
                                    // Let timeout mechanism handle it to keep box visible while barcode is readable
                                }
                                
                                // Continue scanning
                                if (scanning) {
                                    animationFrameId = requestAnimationFrame(scanFrame);
                                }
                            })
                            .catch(err => {
                                // NotFoundException and Timeout are normal - no barcode found
                                // Don't clear immediately - let the timeout mechanism handle it
                                // This keeps the box visible as long as barcode is being detected
                                if (err.name !== 'NotFoundException' && err.message !== 'Timeout') {
                                    // Clear tracking on other errors (not normal "not found" errors)
                                    clearTrackingBox();
                                    lastBarcodeDetectedTime = 0;
                                }
                                // For NotFoundException/Timeout, don't clear immediately
                                // The timeout (1 second) will clear the box only when barcode truly cannot be read
                                
                                // Continue scanning
                                if (scanning) {
                                    animationFrameId = requestAnimationFrame(scanFrame);
                                }
                            });
                    };
                    
                    // Use JPEG for faster encoding (smaller, faster than PNG)
                    img.src = scanCanvas.toDataURL('image/jpeg', 0.85);
                    
                } catch (err) {
                    console.error('Scan frame error:', err);
                    if (scanning) {
                        animationFrameId = requestAnimationFrame(scanFrame);
                    }
                }
            }

            scanFrame();
        }

        let currentBarcodeText = null;
        let currentBarcodeFormat = null;

        function drawTrackingBox(points, barcodeText = null, format = null) {
            console.log('ðŸŸ¢ drawTrackingBox called:', {points: points?.length, barcodeText, format, hasCtx: !!trackingCtx, hasCanvas: !!trackingCanvas});
            
            if (!trackingCtx || !trackingCanvas) {
                console.error('âŒ No tracking context or canvas');
                return;
            }
            
            // Ensure canvas is sized correctly
            if (video && video.videoWidth > 0 && (trackingCanvas.width !== video.videoWidth || trackingCanvas.height !== video.videoHeight)) {
                trackingCanvas.width = video.videoWidth;
                trackingCanvas.height = video.videoHeight;
                console.log('âœ“ Canvas resized to match video:', trackingCanvas.width, 'x', trackingCanvas.height);
            }
            
            if (!points || points.length < 2) {
                console.log('âš ï¸ Invalid points, using center box');
                if (barcodeText) {
                    drawCenterTrackingBox(barcodeText, format);
                } else {
                    clearTrackingBox();
                }
                return;
            }
            
            console.log('âœ“ Drawing green box with', points.length, 'points');

            // Store current barcode info
            if (barcodeText) {
                currentBarcodeText = barcodeText;
            }
            if (format) {
                currentBarcodeFormat = format;
            }

            // Clear previous drawing
            trackingCtx.clearRect(0, 0, trackingCanvas.width, trackingCanvas.height);
            
            // Scale points to match canvas size (if canvas was resized)
            const scaleX = trackingCanvas.width / video.videoWidth;
            const scaleY = trackingCanvas.height / video.videoHeight;
            
            // Calculate bounding box coordinates
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            const scaledPoints = [];
            
            for (let i = 0; i < points.length; i++) {
                const point = points[i];
                let x = point.x;
                let y = point.y;
                
                // Handle different point formats
                if (x === undefined && typeof point.getX === 'function') {
                    x = point.getX();
                }
                if (y === undefined && typeof point.getY === 'function') {
                    y = point.getY();
                }
                
                // Scale coordinates
                x = x * scaleX;
                y = y * scaleY;
                
                scaledPoints.push({x, y});
                
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x);
                maxY = Math.max(maxY, y);
            }
            
            // Draw filled green box (rectangle) around the barcode - make it BIG
            const boxWidth = maxX - minX;
            const boxHeight = maxY - minY;
            const padding = 30; // Big padding to make the box larger
            
            // Draw filled green box with transparency
            trackingCtx.fillStyle = 'rgba(0, 255, 0, 0.25)'; // Semi-transparent green fill
            trackingCtx.fillRect(minX - padding, minY - padding, boxWidth + (padding * 2), boxHeight + (padding * 2));
            
            // Draw green border around the box - make it thicker and more visible
            trackingCtx.strokeStyle = '#00ff00'; // Bright green
            trackingCtx.lineWidth = 6; // Thicker border for bigger box
            trackingCtx.shadowColor = '#00ff00';
            trackingCtx.shadowBlur = 15;
            trackingCtx.strokeRect(minX - padding, minY - padding, boxWidth + (padding * 2), boxHeight + (padding * 2));
            
            // Draw corner markers for better visibility - make them bigger
            trackingCtx.fillStyle = '#00ff00';
            trackingCtx.shadowBlur = 8;
            const cornerSize = 20; // Bigger corner markers
            const cornerThickness = 6; // Thicker corner lines
            // Top-left corner
            trackingCtx.fillRect(minX - padding - 3, minY - padding - 3, cornerSize, cornerThickness);
            trackingCtx.fillRect(minX - padding - 3, minY - padding - 3, cornerThickness, cornerSize);
            // Top-right corner
            trackingCtx.fillRect(minX + boxWidth + padding - cornerSize + 3, minY - padding - 3, cornerSize, cornerThickness);
            trackingCtx.fillRect(minX + boxWidth + padding - 3, minY - padding - 3, cornerThickness, cornerSize);
            // Bottom-left corner
            trackingCtx.fillRect(minX - padding - 3, minY + boxHeight + padding - 3, cornerSize, cornerThickness);
            trackingCtx.fillRect(minX - padding - 3, minY + boxHeight + padding - cornerSize + 3, cornerThickness, cornerSize);
            // Bottom-right corner
            trackingCtx.fillRect(minX + boxWidth + padding - cornerSize + 3, minY + boxHeight + padding - 3, cornerSize, cornerThickness);
            trackingCtx.fillRect(minX + boxWidth + padding - 3, minY + boxHeight + padding - cornerSize + 3, cornerThickness, cornerSize);
            
            // Reset shadow
            trackingCtx.shadowBlur = 0;
            
            // Draw barcode text inside/above the box
            if (currentBarcodeText) {
                const boxWidth = maxX - minX;
                const boxHeight = maxY - minY;
                const centerX = (minX + maxX) / 2;
                const textY = minY - 10; // Position above the box
                
                // Draw background for text
                trackingCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                trackingCtx.fillRect(minX, textY - 30, boxWidth, 35);
                
                // Draw text
                trackingCtx.fillStyle = '#00ff00';
                trackingCtx.font = 'bold 16px Arial';
                trackingCtx.textAlign = 'center';
                trackingCtx.textBaseline = 'middle';
                
                // Split long text into multiple lines if needed
                const maxWidth = boxWidth - 20;
                const text = currentBarcodeText;
                const formatText = currentBarcodeFormat ? `[${currentBarcodeFormat}]` : '';
                
                // Draw format label
                if (formatText) {
                    trackingCtx.font = '12px Arial';
                    trackingCtx.fillStyle = '#ffff00';
                    trackingCtx.fillText(formatText, centerX, textY - 15);
                }
                
                // Draw barcode number
                trackingCtx.font = 'bold 16px Arial';
                trackingCtx.fillStyle = '#00ff00';
                
                // Check if text fits, otherwise truncate
                const metrics = trackingCtx.measureText(text);
                let displayText = text;
                if (metrics.width > maxWidth) {
                    // Truncate with ellipsis
                    let truncated = text;
                    while (trackingCtx.measureText(truncated + '...').width > maxWidth && truncated.length > 0) {
                        truncated = truncated.slice(0, -1);
                    }
                    displayText = truncated + '...';
                }
                
                trackingCtx.fillText(displayText, centerX, textY);
            }
        }
        
        function clearTrackingBox() {
            if (trackingCtx && trackingCanvas) {
                trackingCtx.clearRect(0, 0, trackingCanvas.width, trackingCanvas.height);
            }
            currentBarcodeText = null;
            currentBarcodeFormat = null;
        }
        
        function drawCenterTrackingBox(barcodeText, format) {
            // Draw a green box in center area when barcode is detected but no position points available
            if (!trackingCtx || !trackingCanvas || !barcodeText) return;
            
            // Clear canvas
            trackingCtx.clearRect(0, 0, trackingCanvas.width, trackingCanvas.height);
            
            currentBarcodeText = barcodeText;
            currentBarcodeFormat = format;
            
            const centerX = trackingCanvas.width / 2;
            const centerY = trackingCanvas.height / 2;
            
            // Create a BIG box in the center (typical barcode scanning area)
            const boxWidth = Math.min(500, trackingCanvas.width * 0.8); // Bigger width
            const boxHeight = Math.min(300, trackingCanvas.height * 0.5); // Bigger height
            const boxX = centerX - boxWidth / 2;
            const boxY = centerY - boxHeight / 2;
            
            // Draw filled green box with transparency
            trackingCtx.fillStyle = 'rgba(0, 255, 0, 0.25)'; // Semi-transparent green fill
            trackingCtx.fillRect(boxX, boxY, boxWidth, boxHeight);
            
            // Draw green border around the box - make it thicker
            trackingCtx.strokeStyle = '#00ff00';
            trackingCtx.lineWidth = 6; // Thicker border
            trackingCtx.shadowColor = '#00ff00';
            trackingCtx.shadowBlur = 15;
            trackingCtx.strokeRect(boxX, boxY, boxWidth, boxHeight);
            
            // Draw corner markers - make them bigger
            trackingCtx.fillStyle = '#00ff00';
            trackingCtx.shadowBlur = 8;
            const cornerSize = 20; // Bigger corner markers
            const cornerThickness = 6; // Thicker corner lines
            // Top-left
            trackingCtx.fillRect(boxX - 3, boxY - 3, cornerSize, cornerThickness);
            trackingCtx.fillRect(boxX - 3, boxY - 3, cornerThickness, cornerSize);
            // Top-right
            trackingCtx.fillRect(boxX + boxWidth - cornerSize + 3, boxY - 3, cornerSize, cornerThickness);
            trackingCtx.fillRect(boxX + boxWidth - 3, boxY - 3, cornerThickness, cornerSize);
            // Bottom-left
            trackingCtx.fillRect(boxX - 3, boxY + boxHeight - 3, cornerSize, cornerThickness);
            trackingCtx.fillRect(boxX - 3, boxY + boxHeight - cornerSize + 3, cornerThickness, cornerSize);
            // Bottom-right
            trackingCtx.fillRect(boxX + boxWidth - cornerSize + 3, boxY + boxHeight - 3, cornerSize, cornerThickness);
            trackingCtx.fillRect(boxX + boxWidth - 3, boxY + boxHeight - cornerSize + 3, cornerThickness, cornerSize);
            
            // Reset shadow
            trackingCtx.shadowBlur = 0;
            
            // Draw text above the box
            const textY = boxY - 15;
            
            // Draw background for text
            trackingCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            trackingCtx.fillRect(boxX, textY - 35, boxWidth, 40);
            
            // Draw format label
            if (format && format !== 'UNKNOWN') {
                trackingCtx.font = '12px Arial';
                trackingCtx.fillStyle = '#ffff00';
                trackingCtx.textAlign = 'center';
                trackingCtx.fillText(`[${format}]`, centerX, textY - 15);
            }
            
            // Draw barcode text
            trackingCtx.font = 'bold 16px Arial';
            trackingCtx.fillStyle = '#00ff00';
            trackingCtx.textAlign = 'center';
            
            // Truncate if too long
            let displayText = barcodeText;
            const maxWidth = boxWidth - 20;
            const metrics = trackingCtx.measureText(displayText);
            if (metrics.width > maxWidth) {
                let truncated = barcodeText;
                while (trackingCtx.measureText(truncated + '...').width > maxWidth && truncated.length > 0) {
                    truncated = truncated.slice(0, -1);
                }
                displayText = truncated + '...';
            }
            
            trackingCtx.fillText(displayText, centerX, textY);
        }


        function stopScanning() {
            scanning = false;
            
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            // Clear the timeout interval if it exists
            if (clearCheckInterval) {
                clearInterval(clearCheckInterval);
                clearCheckInterval = null;
            }

            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }

            if (video) {
                video.srcObject = null;
                video.pause();
            }

            clearTrackingBox();

            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            updateStatus(false, 'Camera Stopped');
            lastScannedCode = null;
        }

        function updateStatus(active, text) {
            const status = document.getElementById('status');
            const statusText = document.getElementById('statusText');
            const indicator = status.querySelector('.status-indicator');
            
            if (active) {
                status.className = 'status active';
                indicator.className = 'status-indicator active';
            } else {
                status.className = 'status inactive';
                indicator.className = 'status-indicator inactive';
            }
            
            statusText.textContent = text;
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', stopScanning);
    </script>
</body>
</html>

